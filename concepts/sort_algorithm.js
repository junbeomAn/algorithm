// const arr = [7, 5, 9, 3, 0, 2, 1, 6, 4, 8];
// const arr = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
// const arr = [8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 23, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8, 6, 5, 3, 6, 3, 2, 1, 222, 4, 6, 8, 955, 5, 4, 2, 0, 232, 34, 15, 29, 49, 53, 994,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8,4, 2, 0, 232, 34, 15, 29, 49, 53, 994, 8];

// 삽입정렬
// 데이터의 첫번째 원소는 정렬이 되어있다고 생각하고
// 두번째 데이터부터 해서 첫번째 데이터로 가까이 가면서 각각 데이터와 비교해서 만약 현재 고른 데이터가 더 크다면 그 뒤에다가 데이터를 삽입한다.
// 그렇게해서 세번째 데이터도 앞의 원소들과 비교하여 앞의 원소보다 작으면 삽입할 위치를 변경하고, 크다면 삽입할 위치를 그대로 지정해서 삽입한다.
// 데이터가 거의 정렬된 상태라면 시간 복잡도가 거의 O(N)가까이 나오지만
// 완전히 거꾸로 정렬된 상태라면 n^2 까지 시간복잡도가 나올 수 있다.

function insertionSort (a) {
  for (let i = 1; i < a.length; i++) {
    const curr = a.splice(i, 1)[0];
    let insert = false;

    for (let j = i - 1; j >= 0; j--) {
      if (a[j] < curr) {
        a.splice(j + 1, 0, curr);
        insert = true;
        break;
      }
    }
    if (!insert) {
      a.splice(0, 0, curr);
    }
  }
  console.log(a);
}

function insertionSort2 (a) {
  for (let i = 1; i < a.length; i++) {
    for (let j = i; j >= 0; j--) {
      if (a[j - 1] > a[j]) {
        [a[j - 1], a[j]] = [a[j], a[j - 1]];
      }
    }
  }
  console.log(a);
}

// insertionSort2(arr);

// 퀵 정렬
// 피벗은 기본적으로 데이터중에 가장 왼쪽에 있는 값으로 한다.
// 어떤 값, 피벗을 기준으로해서 데이터의 왼쪽에서부터 피벗보다 작은 값을 찾는다.
// 마찬가지로 데이터의 오른쪽에서부터 피벗보다 큰 값을 찾는다.
// 찾았으면 두 수의 위치를 바꾼다.
// 다시 위 작업을 반복하는데, 만약 두 수의 위치가 엇갈린다면 두 수 중에 작은 수와 피벗의 위치를 바꾼다.
// 피벗의 바뀐 위치를 기준으로 왼쪽 데이터와 오른쪽 데이터에 대해서 각각 재귀적으로 위 작업을 다시 수행한다.
// 사각형 그려서 분할 정복개념.
// 최선으로 생각했을 경우 한번의 분할 시마다 대략적으로 두 부분이 반씩 갈라진다고 생각했을 때 logN 만큼의 깊이로 재귀적 작업을 수행하고,
// 피벗과 비교하는 값을 찾을 때 선형탐색을 수행하므로 N * logN 만큼의 연산 횟수가 발생한다고 볼 수 있다. 일반적으로도 nlogn
// 하지만 최악의 경우 완전히 정렬된 데이터에 대해서 퀵정렬을 수행한다면 피벗보다 작은값과 큰 값을 찾는데 선형탐색을 수행하기 때문에, 각각 큰값과 작은 값을 찾지못하고 N번의 탐색을 모두 수행.
// 피벗을 기준으로 나누어 지는부분도 편향적으로 발생하게 된다면 N^2의 시간복잡도가 나올 수 있다.

function quickSort (a, start, end) {
  if (start >= end) return;

  let left = start;
  let right = end;
  const pivot = a[left];

  while (left <= right) {
    while (left <= end && pivot >= a[left]) {
      left += 1;
    }
    while (start < right && pivot <= a[right]) {
      right -= 1;
    }
    if (left <= right) {
      [a[left], a[right]] = [a[right], a[left]];
    }
  }
  [a[right], a[start]] = [a[start], a[right]];

  quickSort(a, start, right - 1);
  quickSort(a, right + 1, end);
}

// quickSort(arr, 0, arr.length - 1);
// console.log(arr);


// 병합 정렬
/*
퀵 정렬과 마찬가지로 분할 정복 개념을 도입한 정렬이다. 근데 퀵 정렬은 최악의 경우 N^2의 성능을 내는데 비해서 병합정렬은 nlogn의 성능을 보장한다는 특징이 있다.
퀵정렬은 피벗에 따라서 편향적인 분할이 될 수도 있는데, 병합 정렬은 데이터를 반으로 계속 나누는 것을 보장하기 때문이다. 다만 일반적으로는 퀵정렬이 더 빠르다.
데이터를 반으로 계속 쪼개서 각각의 데이터가 하나가 되었을 때부터 시작한다. 길이가 1인 두 데이터 배열을 비교해서 정렬한다. 다음으로 길이가 2인 두 데이터 배열을 합쳐서 정렬된 배열을 만들게 되는데 각각의 배열은
정렬이 이미 되어있기때문에, 두 배열의 첫번째 원소를 비교하여 큰 것을 정렬된 새배열에 집어넣는다. 그렇게 각각에서 하나씩 가져오는 방식으로 N의 사간복잡도가 나오게된다.
그렇게 배열을 정렬하면서 합치게 되면 전체 배열이 정렬된다.
부분적으로 정렬한 데이터를 담을 추가적인 배열이 필요.
*/
const sorted = [];

function merge (a, start, middle, end) {
  let curr = start; // sorted에 넣기 시작할 위치 (원래 배열 a 상에서의 위치)
  let i = start; // 왼쪽 배열의 시작 위치
  let j = middle + 1; // 오른쪽 배열의 시작위치
  // 왼쪽 혹은 오른쪽 데이터를 다 집어 넣을 때까지
  while (i <= middle && j <= end) {
    // 왼쪽 데이터의 값이 더 작을 때
    if (a[i] < a[j]) {
      sorted[curr] = a[i];
      i += 1;
    } else { // 오른쪽 데이터의 값이 더 작을 때
      sorted[curr] = a[j];
      j += 1;
    }
    curr += 1;
  }
  // 왼쪽 배열의 데이터를 덜 넣었을 경우
  while (i <= middle) {
    sorted[curr] = a[i];
    i += 1;
    curr += 1;
  }
  // 오른쪽 배열의 데이터를 덜 넣었을 경우
  while (j <= end) {
    sorted[curr] = a[j];
    j += 1;
    curr += 1;
  }
  // a에다가 정렬된 데이터를 start ~ end 인덱스에 차례로 넣어준다.
  for (let k = start; k <= end; k++) {
    a[k] = sorted[k];
  }
}

function mergeSort (a, start, end) {
  // 쪼개진 부분의 데이터가 하나일 경우
  if (start >= end) return;

  const middle = Math.floor((start + end) / 2);
  // 재귀적으로 왼쪽부분과 오른쪽 부분으로 반씩 나누어 데이터 크기가 1인 상태까지 들어간다.
  mergeSort(a, start, middle);
  mergeSort(a, middle + 1, end);
  // 쪼개진 start, middle, end에 따라서 병합.
  merge(a, start, middle, end);
}

// mergeSort(arr, 0, arr.length - 1);
// console.log(arr);

function heapSort (heap) {
  function heapify (i) {
    const len = heap.length;
    let stop = false;
    let child;

    while (!stop) {
      child = 2 * i + 1;
      if (child < len - 1 && heap[child] < heap[child + 1]) {
        child += 1;
      }
      if (child < len && heap[i] < heap[child]) {
        [heap[i], heap[child]] = [heap[child], heap[i]];
      } else {
        stop = true;
      }
      i = child;
    }
  }
  // 힙 생성.
  for (let i = heap.length - 1; i >= 0; i--) {
    heapify(i);
  }

  // 루트(가장 큰수)를 맨 뒤로 보내고, 맨 뒤 수를 루트로 가져와서 정렬.
  for (let i = heap.length - 1; i >= 0; i--) {
    let root = 0;
    let stop = false;
    let child;
    // 루트와 맨 뒷자리 수를 교환
    [heap[root], heap[i]] = [heap[i], heap[root]];

    while (!stop) {
      // 루트의 왼쪽 자식
      child = 2 * root + 1;
      // 오른쪽 자식 있는지 확인후 오른쪽 자식이 더 크면 오른쪽을 선택(+1).
      if (child < i - 1 && heap[child] < heap[child + 1]) {
        child += 1;
      }
      // 현재 루프에서 맨 뒤로 보낸 가장 큰 수보다 작은 범위에서,
      // 현재 자식이 루트보다 커버리면 교환. 더이상 교환할 수 없거나
      // 이미 맨 뒤로 보내버려서 자리가 fix 된 i 이상의 수와 비교하게 되면 루프 종료.
      if (child < i && heap[root] < heap[child]) {
        [heap[child], heap[root]] = [heap[root], heap[child]];
      } else {
        stop = true;
      }
      // 새로운 부모는 항상 자식으로~
      root = child;
    }
  }
}

// heapSort(arr);

function swap(q, i, j) {
  const temp = q[i];
  q[i] = q[j];
  q[j] = temp;
}

function heapPush(q, node) {
  q.push(node);
  let index = q.length - 1;
  let parentIndex = Math.floor((index - 1) / 2);

  while (index > 0 && q[index] < q[parentIndex]) {
    swap(q, index, parentIndex);
    index = parentIndex;
    parentIndex = Math.floor((index - 1) / 2);
  }
}

function heapPop(q) {
  const ret = q[0];

  let index = 0;
  let child;

  q[0] = q[q.length - 1];
  q.pop();

  if (q.length === 0) {
    return ret;
  }

  while (q.length > 1) {
    child = index * 2 + 1;
    if (child >= q.length) {
      break;
    }

    if (child < q.length - 1 && q[child] > q[child + 1]) {
      child = child + 1;
    }
    if (child === index) {
      break;
    }
    if (q[child] > q[index]) {
      break;
    }
    swap(q, index, child);
    index = child;
  }

  return ret;
}


/*
배열을 요청시간 기준 으로 오름차순으로 정렬

현재시간 이하의 요청시간을 가지는 job을 우선순위 큐에 등록
큐는 작업시간을 기준 으로 오름차순으로 정렬
큐에서 1개의 job을 꺼내서 현재시간을 업데이트 하고 해당 job의 총 실행시간(대기시간 + 작업시간)을 계산하고 업데이트
 */
function solution(jobs) {

  jobs.sort((a, b) => a[0] - b[0]);

  let currTime = jobs[0][0];
  let taskArrive, taskTime;
  let spend = 0;
  let i = 0;

  const pq = [];

  while (i < jobs.length || pq.length) {

    if ((i < jobs.length && currTime >= jobs[i][0])) {
      heapPush(pq, jobs[i]);
      i++;
    } else {
      if (pq.length === 0) {
          heapPush(pq, jobs[i]);
          i++;
          currTime = pq[0][0];
      } else {
        [taskArrive, taskTime] = heapPop(pq);
      spend += ((currTime - taskArrive) + taskTime);
      currTime += taskTime;
      }

    }
  }
  return Math.floor(spend / jobs.length);
}

